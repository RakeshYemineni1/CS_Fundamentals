    title: 'Page Replacement Algorithms (FIFO, LRU, Optimal)',
    explanation: 'Page replacement algorithms determine which page to evict from memory when a new page needs to be loaded and memory is full. Different algorithms optimize for different metrics and have varying implementation complexity and performance characteristics.',
    keyPoints: [
      'FIFO replaces oldest loaded page (simple but Belady\'s anomaly)',
      'LRU replaces least recently used page (good performance, high overhead)',
      'Optimal replaces page used farthest in future (theoretical minimum)',
      'Clock algorithm approximates LRU with lower overhead',
      'Working set model prevents thrashing',
      'Page replacement critical for virtual memory performance'
    ],
    codeExamples: [{
      title: 'Page Replacement Algorithms Implementation',
      language: 'java',
      code: `// FIFO Page Replacement
class FIFOPageReplacement {
    private Queue<Integer> pageQueue;
    private Set<Integer> pagesInMemory;
    private int frameCount;
    private int pageFaults;
    
    public FIFOPageReplacement(int frameCount) {
        this.frameCount = frameCount;
        this.pageQueue = new LinkedList<>();
        this.pagesInMemory = new HashSet<>();
        this.pageFaults = 0;
    }
    
    public boolean accessPage(int pageNumber) {
        if (pagesInMemory.contains(pageNumber)) {
            return false; // Page hit
        }
        
        pageFaults++;
        
        if (pagesInMemory.size() < frameCount) {
            // Memory not full
            pagesInMemory.add(pageNumber);
            pageQueue.offer(pageNumber);
        } else {
            // Memory full - replace oldest page
            int victimPage = pageQueue.poll();
            pagesInMemory.remove(victimPage);
            pagesInMemory.add(pageNumber);
            pageQueue.offer(pageNumber);
        }
        return true; // Page fault
    }
}

// LRU Page Replacement
class LRUPageReplacement {
    private LinkedHashMap<Integer, Integer> pageMap;
    private int frameCount;
    private int pageFaults;
    
    public LRUPageReplacement(int frameCount) {
        this.frameCount = frameCount;
        this.pageFaults = 0;
        // LinkedHashMap maintains insertion/access order
        this.pageMap = new LinkedHashMap<Integer, Integer>(frameCount, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return size() > frameCount;
            }
        };
    }
    
    public boolean accessPage(int pageNumber) {
        if (pageMap.containsKey(pageNumber)) {
            // Page hit - update access time
            pageMap.get(pageNumber); // This moves to end in access-order LinkedHashMap
            return false;
        }
        
        pageFaults++;
        pageMap.put(pageNumber, pageNumber);
        return true; // Page fault
    }
}

// Optimal Page Replacement (Theoretical)
class OptimalPageReplacement {
    private Set<Integer> pagesInMemory;
    private int frameCount;
    private int pageFaults;
    
    public OptimalPageReplacement(int frameCount) {
        this.frameCount = frameCount;
        this.pagesInMemory = new HashSet<>();
        this.pageFaults = 0;
    }
    
    public boolean accessPage(int pageNumber, int[] futureReferences, int currentIndex) {
        if (pagesInMemory.contains(pageNumber)) {
            return false; // Page hit
        }
        
        pageFaults++;
        
        if (pagesInMemory.size() < frameCount) {
            pagesInMemory.add(pageNumber);
        } else {
            // Find page that will be used farthest in future
            int victimPage = findOptimalVictim(futureReferences, currentIndex);
            pagesInMemory.remove(victimPage);
            pagesInMemory.add(pageNumber);
        }
        return true;
    }
    
    private int findOptimalVictim(int[] futureReferences, int currentIndex) {
        int farthest = currentIndex;
        int victimPage = -1;
        
        for (Integer page : pagesInMemory) {
            int nextUse = findNextUse(page, futureReferences, currentIndex + 1);
            if (nextUse > farthest) {
                farthest = nextUse;
                victimPage = page;
            }
        }
        
        return victimPage != -1 ? victimPage : pagesInMemory.iterator().next();
    }
    
    private int findNextUse(int page, int[] references, int startIndex) {
        for (int i = startIndex; i < references.length; i++) {
            if (references[i] == page) {
                return i;
            }
        }
        return Integer.MAX_VALUE; // Never used again
    }
}

// Clock (Second Chance) Algorithm
class ClockPageReplacement {
    private int[] frames;
    private boolean[] referenceBits;
    private int clockHand;
    private Set<Integer> pagesInMemory;
    private int frameCount;
    private int pageFaults;
    
    public ClockPageReplacement(int frameCount) {
        this.frameCount = frameCount;
        this.frames = new int[frameCount];
        this.referenceBits = new boolean[frameCount];
        this.clockHand = 0;
        this.pagesInMemory = new HashSet<>();
        this.pageFaults = 0;
        Arrays.fill(frames, -1);
    }
    
    public boolean accessPage(int pageNumber) {
        if (pagesInMemory.contains(pageNumber)) {
            // Page hit - set reference bit
            setReferenceBit(pageNumber);
            return false;
        }
        
        pageFaults++;
        
        // Find frame for new page
        int frameIndex = findVictimFrame();
        
        // Remove old page if frame was occupied
        if (frames[frameIndex] != -1) {
            pagesInMemory.remove(frames[frameIndex]);
        }
        
        // Load new page
        frames[frameIndex] = pageNumber;
        referenceBits[frameIndex] = true;
        pagesInMemory.add(pageNumber);
        
        return true;
    }
    
    private int findVictimFrame() {
        while (true) {
            if (frames[clockHand] == -1) {
                // Empty frame
                return clockHand;
            }
            
            if (!referenceBits[clockHand]) {
                // Found victim (reference bit = 0)
                return clockHand;
            }
            
            // Give second chance (clear reference bit)
            referenceBits[clockHand] = false;
            clockHand = (clockHand + 1) % frameCount;
        }
    }
    
    private void setReferenceBit(int pageNumber) {
        for (int i = 0; i < frameCount; i++) {
            if (frames[i] == pageNumber) {
                referenceBits[i] = true;
                break;
            }
        }
    }
}

// Enhanced Second Chance (NRU - Not Recently Used)
class NRUPageReplacement {
    private PageFrame[] frames;
    private int clockHand;
    private int frameCount;
    
    class PageFrame {
        int pageNumber;
        boolean referenceBit;
        boolean modifyBit;
        
        int getClass() {
            if (!referenceBit && !modifyBit) return 0; // Not referenced, not modified
            if (!referenceBit && modifyBit) return 1;  // Not referenced, modified
            if (referenceBit && !modifyBit) return 2;  // Referenced, not modified
            return 3; // Referenced, modified
        }
    }
    
    public int findVictimPage() {
        // Look for lowest class page
        for (int cls = 0; cls <= 3; cls++) {
            for (int i = 0; i < frameCount; i++) {
                int index = (clockHand + i) % frameCount;
                if (frames[index].getClass() == cls) {
                    clockHand = (index + 1) % frameCount;
                    return index;
                }
            }
        }
        return clockHand; // Fallback
    }
}`
    }],
    questions: [
      { question: "Compare FIFO, LRU, and Optimal page replacement algorithms.", answer: "FIFO: replaces oldest page, simple implementation, suffers from Belady's anomaly. LRU: replaces least recently used, excellent performance with good locality, high implementation overhead. Optimal: replaces page used farthest in future, theoretically minimum page faults, impossible to implement (requires future knowledge)." },
      { question: "What is Belady's anomaly and which algorithms suffer from it?", answer: "Belady's anomaly occurs when increasing number of page frames results in more page faults instead of fewer. FIFO algorithm suffers from this anomaly. LRU and Optimal algorithms are stack algorithms and don't exhibit Belady's anomaly - more frames always result in fewer or equal page faults." },
      { question: "How does the Clock (Second Chance) algorithm work?", answer: "Clock algorithm uses circular list of pages with reference bits. When replacement needed: if reference bit = 0, replace page; if reference bit = 1, set to 0 and move to next page. Approximates LRU with lower overhead, gives pages 'second chance' before replacement." },
      { question: "What are the implementation challenges of LRU?", answer: "LRU requires tracking access order for all pages. Implementations: counter method (timestamp on each access), stack method (maintain stack of page numbers), hardware support needed for efficiency. High overhead makes pure LRU impractical, leading to approximation algorithms like Clock." },
      { question: "Explain the Not Recently Used (NRU) algorithm.", answer: "NRU uses reference and modify bits to classify pages into 4 classes: (0) not referenced, not modified, (1) not referenced, modified, (2) referenced, not modified, (3) referenced, modified. Replaces page from lowest non-empty class. Periodically clears reference bits." },
      { question: "How do you measure page replacement algorithm performance?", answer: "Metrics: page fault rate (lower better), hit ratio (higher better), working set size, memory utilization. Factors affecting performance: locality of reference, memory size, page size, algorithm overhead. Trace-driven simulation used for evaluation with real workloads." },
      { question: "What is the working set model and how does it relate to page replacement?", answer: "Working set W(t,Î”) = set of pages referenced in last Î” time units. Represents process's memory requirements for efficient execution. Page replacement should maintain working sets in memory to prevent thrashing. Working set size guides memory allocation decisions." },
      { question: "How do modern systems implement LRU approximation?", answer: "Hardware support: reference bits set by MMU on page access. Software algorithms: Clock/Second Chance, NRU, aging (shift reference bits periodically). Multi-level approaches: separate algorithms for different page types. Goal is balance between accuracy and overhead." },
      { question: "What factors influence the choice of page replacement algorithm?", answer: "System type (interactive vs batch), memory size, page fault cost, hardware support available, implementation complexity, locality patterns of applications. Interactive systems prefer algorithms with good response time, batch systems may prioritize throughput." },
      { question: "How do you handle page replacement in multi-level memory systems?", answer: "Different algorithms for different levels: L1/L2 cache (LRU hardware), main memory (Clock/NRU), disk (LRU approximation). Consider access costs at each level, prefetching strategies, and coordination between levels. Modern systems use adaptive algorithms based on access patterns." }
    ]
  }
];

// Advanced Topics
const advancedOSTopics = [];

export const osTopics = [...coreOSTopics, ...advancedOSTopics];
